/**
 * @file realscanner.c
 * @author xgarip00
 * @brief Real code scanner
 * @version 0.1
 */


#include <stdio.h>
#include <string.h>
#include "../main.h"
#include "../common/queue.c"
#include "token.c"

void Scan(void)
{
 /* Setting up default values for queues & tokens */
 
 queue_t *queue = init_queue();
 token_t *token = init_token();

/*Reading 1 character from a file until we reach the end of it*/
 
 FILE *file;
 char newChar;
 while (!feof(file))
 {
   newChar = fgetc(file);
   
   switch(newChar)
   {
    
    /*Possible reading variations for operands '+','-', ',' , '.', ':', '(', ')', '{', '}' */
    
     case '(':
     case ')':
     case '+':
     case ':':
     case ',':
     case '-':
     case '.':
     case '{':
     case '}':
     
     /*If it's not in quotes or a comment, then we create a new token for the operator and write it there*/
       
       if (token->type != STRING_LITERAL && token->type != COMMENT)
        {
         push_token_in_queue(queue, &token);
         token->type = OPERATOR;
         push_char_in_token(&token, newChar);
         push_token_in_queue(queue, &token);
        } 

        /*Otherwise, continue writing to the existing token*/
        
        else
        {
         push_char_in_token(&token->text, newChar);
        }
     break;

     /*Possible reading variations for numbers*/

     case '0'...'9':

     /*If it's not in quotes or a comment or an identifire then we create a new token for the INT literal and write it there*/

       if (token->type != STRING_LITERAL &&
            token->type != COMMENT &&
            token->type != ID_NAME)
       {
         push_char_in_token(&token->text,newChar);
         token->type = INT_LITERAL;
       } 

       /*Otherwise, continue writing to the existing token*/

       else
       {
        push_char_in_token(&token->text, newChar);
       }
      break;

      /*Possible reading variations for operand '<'*/

      case '<':

       /*If it's not in quotes or a comment, then we create a new token for the operator or keyword '<?php' and write it there*/

        if (token->type != STRING_LITERAL &&
            token->type != COMMENT)
        {
          push_token_in_queue(queue,&token);
          token->type = POSSIBLE_KEYWORD;
          push_char_in_token(&token->text, newChar);
        }

        /*Otherwise, continue writing to the existing token*/

        else
        {
          push_char_in_token(&token->text, newChar);
        }
      break;

      /*Possible reading variations for operand '>'*/

      case '>':

       /*If it's not in quotes or a comment or a possible keyword, then we create a new token for the operator  and write it there*/

        if (token->type != STRING_LITERAL &&
            token->type != COMMENT &&
            token->type != KEYWORD)
        {
          push_token_in_queue(queue,&token);
          token->type = OPERATOR;
          push_char_in_token(&token->text, newChar);
        }

        /*Otherwise if type of token is keyword, so write the operand to the token and save token with '?>' keyword */

        else if (token->type == KEYWORD)
        {
          push_char_in_token(&token->text, newChar);
          push_token_in_queue(queue,&token);
        }

        /*Otherwise, continue writing to the existing token*/

        else
        {
           push_char_in_token(&token->text, newChar);
        }
      break;

      /*Possible reading variations for key simbol '?'*/

      case '?':

       /*If it's not in quotes or a comment or a possible keyword '<?php', then we create a new token for the keyword '?>'  and write it there*/

        if (token->type != STRING_LITERAL &&
            token->type != COMMENT &&
            token->type != POSSIBLE_KEYWORD)
        {
          push_token_in_queue(queue,&token);
          token->type = KEYWORD;
          push_char_in_token(&token->text, newChar);
        }

        /*Otherwise, continue writing to the existing token*/

        else
        {
          push_char_in_token(&token->text, newChar);
        }
      break;
    }
  }
  node_t*node = queue->head;

    while(node){
        print_token(node->data);
        node = node->next;
    }

    /* clean up */

    free_token(token);
    free_queue(queue, free_token);

    return 0;
}


 